-- Day 06 


-- 시퀀스 옵션 CYCLE / CACHE 
-- CYCLE : 시퀀스값이 최대값 or 최소값 도달했을 때 반대의 값부터 시작하는 옵션
CREATE SEQUENCE SEQ_CYCLE
START WITH 200 
INCREMENT BY 10 
MAXVALUE 230 
MINVALUE 15
CYCLE 
NOCACHE; 

SELECT SEQ_CYCLE.NEXTVAL FROM DUAL;	-- 200
SELECT SEQ_CYCLE.NEXTVAL FROM DUAL;	-- 210
SELECT SEQ_CYCLE.NEXTVAL FROM DUAL;	-- 220
SELECT SEQ_CYCLE.NEXTVAL FROM DUAL;	-- 230 -- 최대값 도달
SELECT SEQ_CYCLE.NEXTVAL FROM DUAL; -- 15

SELECT * FROM USER_SEQUENCES; 

-- CACHE / NOCACHE
-- CACHE : 컴퓨터가 다음 값에 대한 연산들을 미리 계산해 놓은 것

CREATE SEQUENCE SEQ_CACHE 
START WITH 100 
CACHE 20 
NOCYCLE; 

-- 그때그때 계산함 
CREATE SEQUENCE SEQ_NOCACHE 
START WITH 100 
NOCACHE
NOCYCLE; 

SELECT * FROM USER_SEQUENCES WHERE SEQUENCE_NAME LIKE '%CACHE'; 

SELECT SEQ_CACHE.NEXTVAL, SEQ_NOCACHE.NEXTVAL FROM DUAL;

-- INDEX -- 
-- SQL 명령어 조회처리속도를 향상시키기 위한 객체 

-- 장점 : 검색속도 향상 
-- 단점 : 만약 테이블 내용이 자주 변경되는 테이블이라면
--		변경될 때마다 인덱스를 다시 계산하여 만들어야 한다
--		성능이 저하될 수 있다.   
-- 		인덱스 저장을 위한 별도의 공간이 필요 

SELECT * FROM USER_IND_COLUMNS; 

SELECT ROWID, EMP_ID, EMP_NAME 
FROM EMPLOYEE; 

-- ROWID 
--	데이터의 순번, 오라클에서 테이블 생성, 데이터 추가시에 해당 객체들을 관리하기 위한 순번
-- SQL Error [1408] [72000]: ORA-01408: 열 목록에는 이미 인덱스가 작성되어 있습니다
CREATE UNIQUE INDEX IDX_EMP_NO 
ON EMPLOYEE(EMP_NO);

-- 고유 인덱스
--	인덱스 생성시 고유값(유니크값)을 기준으로 생성하는 인덱스 
--	오라클에서 자동으로 생성하는 인덱스
-- 	해당 칼럼을 SELECT문으로 조회할 때 포함시키면
--	조회할 때 고유 인덱스를 이용해서 검색속도를 향상시킨다. 

SELECT EMP_NAME, DEPT_CODE, JOB_CODE 
FROM EMPLOYEE 
WHERE DEPT_CODE = 'D6';

CREATE INDEX IDX_DEPT_CODE 
ON EMPLOYEE(DEPT_CODE);

-- 결합 인덱스 (COMPOSITE INDEX)
CREATE INDEX IDX_DEPT 
ON DEPARTMENT(DEPT_ID, DEPT_TITLE); 

SELECT * FROM DEPARTMENT D;

-- 인덱스 새로고침 
ALTER INDEX IDX_DEPT REBUILD;

-- 삭제 
DROP INDEX IDX_DEPT; 


-------------------------------------------------------------------------
/* ORACLE
 * DBMS 
 * 데이터를 효율적으로 관리하기 위한 시스템
 * 
 * SQL
 * 	DDL : 데이터 정의어. 
 * 		CREATE, ALTER, DROP
 * 
 * 	DML : 데이터 조작어
 * 		CRUD 
 * 			CREATE 	: INSERT
 * 			READ 	: SELECT
 * 			UPDATE	: UPDATE
 * 			DELETE	: DELETE
 * 
 * 	DCL : 데이터 제어어
 * 		GRANT, REVOKE, COMMIT, ROLLBACK 
 * 
 *  SET OPERATOR 
 * 		UNION, UNION ALL, INTERSECT, MINUS    
 * 
 *  JOIN 
 * 		INNER JOIN : 두 개 이상의 테이블에서 같은 값끼리 묶여서 결과셋을 만드는 방식 
 * 					작성한 조건이 일치하는 것만 처리
 * 		OUTER JOIN : 서로 다른 값도 포함하기 위해서 사용 
 * 			LEFT, RIGHT, FULL 
 * 
 * ORACLE 객체 
 * 	USER, TABLE, VIEW, SEQUENCE, INDEX 
 * 		TABLE : 직사각형 표의 형태로 데이터를 저장하고 표현하는 데이터베이스 객체 
 * 		VIEW : SELECT 쿼리를 저장하여, 필요시 가져다 사용하는 가상의 테이블 (편리성, 보안성) 
 * 		SEQUENCE : 1, 2, 3, 4 ... 순서를 자동으로 증감시키는 데이터베이스 객체
 * 		INDEX : 테이블에서 데이터 검색시 빠르게 검색하기 위한 객체  
 * */

-- PL / SQL -- 
-- [구성]
-- DECLARE 
-- END; 
-- /

-- 프로시저 : PL/SQL을 미리 저장해 놓았다가 호출하여 함수처럼 동작시키는 객체 
-- [사용형식]
-- CREATE [OR REPLACE] PROCEDURE 프로시저명(매개변수1 [IN/OUT/IN OUT] 자료형, ...)
--											IN: 외부에서 값을 받아올 때 사용하는 모드 
--											OUT : 프로시저 실행 결과를 외부로 추출 (RETURN)
-- IS 
--		변수 선언
-- BEGIN
--		실행할 스크립트
-- END; 
-- /

-- [호출방식]
-- EXEC 프로시저명 [(전달값...)]

-- [삭제]
-- DROP PROCEDURE 프로시저명; 

-- 예시
-- PL / SQL 
DECLARE 
	DUP_EMP_ID EXCEPTION;
BEGIN 
	UPDATE EMPLOYEE; 
	SET EMP_ID = '20000'
	WHERE EMP_ID = '201'
EXCEPTION
	WHEN DUP_EMP_ID THEN DBMS_OUTPUT.PUT_LIE('이미 존재');
END;
/

CREATE TABLE EMP_TMP 
AS SELECT * FROM EMPLOYEE;

-- 프로시저 생성 
SELECT * FROM EMP_TMP;

CREATE OR REPLACE PROCEDURE DEL_ALL_EMP
IS 
	-- 변수 선언 ... 
BEGIN
	DELETE FROM EMP_TMP;
	COMMIT;
END;

-- SQL Error [900] [42000]: ORA-00900: SQL 문이 부적합합니다
SELECT COUNT(*) FROM EMP_TMP; 
EXECUTE DEL_ALL_EMP;

-- 
CREATE OR REPLACE FUNCTION BONUS_CALC(V_EMP_ID IN EMPLOYEE.EMP_ID%TYPE)
RETURN NUMBER 
IS
	V_SAL EMPLOYEE.SALARY%TYPE;
	V_BONUS EMPLOYEE.BONUS&TYPE; 
	RES NUMBER; 
BEGIN 
	SELECT SALARY, NVL(BONUS, 0)
	INTO V_SAL, V_BONUS 
	FROM EMPLOYEE 
	WHERE EMPLOYEE.EMP_ID = V_EMP_ID; 

	RES := V_SAL * V_BONUS; 
	RETURN RES; 
END;

SELECT EMP_NAME, BONUS_CALC(EMP_ID)
FROM EMPLOYEE; 

SELECT EMP_NAME, SALARY, (SALARY+BONUS_CALC(EMP_ID))*12 연봉
FROM EMPLOYEE;

-- TRIGGER --
-- 특정 테이블에 DML을 통해서 데이터 변환이 일어날 때
-- 그 시점을 감지하여 자동으로 동작 

-- 테이블 생성
CREATE TABLE PRODUCT(
	PCODE NUMBER PRIMARY KEY,
	PNAME VARCHAR2(30),
	BRAND VARCHAR2(30),
	PRICE NUMBER, 
	STOCK NUMBER DEFAULT 0	
);

-- 제품 입출고 내역 테이블
CREATE TABLE PRODUCT_DETAIL (
	DCODE NUMBER PRIMARY KEY, 
	PCODE NUMBER NOT NULL,
	PDATE DATE DEFAULT SYSDATE,
	AMOUNT NUMBER,
	STATUS CHAR(6) CHECK(STATUS IN ('입고', '출고')),
	CONSTRAINT FK_PRODUCT FOREIGN KEY(PCODE) REFERENCES PRODUCT
);

SELECT * FROM PRODUCT;
SELECT * FROM PRODUCT_DETAIL;

CREATE SEQUENCE SEQ_PRODUCT NOCACHE; 
CREATE SEQUENCE SEQ_DETAIL NOCACHE;


-- 제품 등록
INSERT INTO PRODUCT 
VALUES(SEQ_PRODUCT.NEXTVAL, '노트북', 'apple', 2000000, DEFAULT); 

INSERT INTO PRODUCT 
VALUES(SEQ_PRODUCT.NEXTVAL, '휴대폰', '삼성', 1500000, DEFAULT);

INSERT INTO PRODUCT 
VALUES(SEQ_PRODUCT.NEXTVAL, 'TV', 'LG', 2500000, DEFAULT);

INSERT INTO PRODUCT 
VALUES(SEQ_PRODUCT.NEXTVAL, '모나미볼펜', '모나미', 1000, DEFAULT);

SELECT * FROM PRODUCT;

-- 제품 입출고 관련 재고 증감 트리거
-- DETAIL에 입/출고가 된다면
-- PRODUCT에 재고 값을 증감시킨다.

CREATE OR REPLACE TRIGGER TRG_01 
ALTER INSERT ON PRODUCT_DETAIL 
FOR EACH ROW 
BEGIN 
	IF	:NEW.STATUS = '입고'
	THEN 
		UPDATE PRODUCT 
		SET STOCK = STOCK + :NEW.AMOUNT
		WHERE PCODE = :NEW.PCODE;
	END IF; 

	IF :NEW.STATUS = '출고'
	THEN 
		UPDATE PRODUCT
		SET STOCK = STOCK - :NEW.AMOUNT 
		WHERE PCODE = :NEW.PCODE; 
	END IF;
END;

INSERT INTO PRODUCT_DETAIL 
VALUES(SEQ_DETAIL.NEXTVAL, 1, SYSDATE, 3, '입고');

SELECT * FROM PRODUCT_DETAIL;
SELECT * FROM PRODUCT;


CREATE OR REPLACE TRIGGER TRG_01
AFTER INSERT ON PRODUCT_DETAIL
FOR EACH ROW
BEGIN
	IF :NEW.STATUS = '입고'
	THEN
		UPDATE PRODUCT
		SET STOCK = STOCK + :NEW.AMOUNT
		WHERE PCODE= :NEW.PCODE;
	END IF;

	IF :NEW.STATUS='출고'
	THEN 
		UPDATE PRODUCT	
		SET STOCK = STOCK - :NEW.AMOUNT
		WHERE PCODE = :NEW.PCODE;
	END IF;
END;

INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 1, SYSDATE, 3,'입고');

SELECT * FROM PRODUCT_DETAIL;
SELECT * FROM PRODUCT;
-- 입고
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 2, SYSDATE, 100,'입고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 3, SYSDATE, 200,'입고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 4, SYSDATE, 1000,'입고');
-- 출고
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 1, SYSDATE, 1,'출고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 2, SYSDATE, 60,'출고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 3, SYSDATE, 30,'출고');
INSERT INTO PRODUCT_DETAIL
VALUES(SEQ_DETAIL.NEXTVAL, 4, SYSDATE, 200,'출고');

SELECT * FROM JOB;
SELECT * FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);

DROP TABLE MYTEST;

CREATE TABLE MYTEST(
	MNO NUMBER,
	MNAME VARCHAR2(20),
	NICKNAME VARCHAR2(20)
);

SELECT * FROM MYTEST;
INSERT INTO MYTEST VALUES(1, 'LEE', 'TTTT');

SELECT * FROM MYTEST;

---------------------------------------------------------------

DROP TABLE PRODUCT;
DROP TABLE PRODUCT_DETAIL;

CREATE TABLE PRODUCT(
	P_ID VARCHAR2(20) PRIMARY KEY, 
	P_NAME VARCHAR2(20) NOT NULL,
	PRICE NUMBER NOT NULL, 
	DES VARCHAR2(50)
);

INSERT INTO PRODUCT VALUES('LT-SS1', '삼성노트북', 2000000, '갤럭시북');
INSERT INTO PRODUCT VALUES('LT-LG1', 'LG노트북', 1800000, 'gram');
INSERT INTO PRODUCT VALUES('PC-AP2', 'apple컴퓨터', 3000000, 'mac');

SELECT * FROM PRODUCT;

----------------------------------------------------------------------------

DROP TABLE MYBOARD;
DROP SEQUENCE SEQ_MYBOARD;

CREATE SEQUENCE SEQ_MYBOARD NOCACHE;
CREATE TABLE MYBOARD(
	MYNO NUMBER PRIMARY KEY,
	MYNAME VARCHAR2(20) NOT NULL,
	MYTITLE VARCHAR2(1000) NOT NULL,
	MYCONTENT VARCHAR2(4000) NOT NULL, 
	MYDATE DATE NOT NULL
);

INSERT INTO MYBOARD VALUES(SEQ_MYBOARD.NEXTVAL, '관리자', '게시판 테스트', 
	'테스트 중입니다. 
	1234567890ABCD', SYSDATE);

SELECT * FROM MYBOARD;

INSERT INTO MYBOARD VALUES(SEQ_MYBOARD.NEXTVAL, '최유리', '3교시', '집가고싶다... 집에갑시다.', SYSDATE);

---------------------------------------------------------------------------------

DROP TABLE BOARD;
DROP SEQUENCE SEQ_BOARD;

CREATE SEQUENCE SEQ_BOARD NOCACHE;

CREATE TABLE BOARD(
	SEQ NUMBER PRIMARY KEY,
	WRITER VARCHAR2(500) NOT NULL,
	TITLE VARCHAR2(2000) NOT NULL,
	CONTENT VARCHAR2(4000) NOT NULL,
	REGDATE DATE NOT NULL
);

INSERT INTO BOARD VALUES(SEQ_BOARD.NEXTVAL, '관리자', '테스트 중', 'TEST1234가나다라', SYSDATE);
SELECT * FROM BOARD;















