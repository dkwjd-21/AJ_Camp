 -- DAY 3 --

-- 숫자 데이터 함수

-- ABS() : 절대값 표현
SELECT ABS(10), ABS(-10)
FROM DUAL;

-- MOD() : 주어진 컬럼이나 값을 나눈 나머지를 반환
SELECT MOD(10, 3), MOD(10, 6), (10/6)
FROM DUAL;

-- CEIL() : 소수 첫째 자리에서 올림
-- FLOOR() : 소수점 이하 숫자를 버림 
SELECT CEIL(123.456), CEIL(123.678), CEIL(123),
		FLOOR(123.456), FLOOR(123.678), FLOOR(123)
FROM DUAL;

-- TRUNC() : 지정한 위치에서부터 버림
SELECT TRUNC(123.456, 0),
	   TRUNC(123.456, 1),
	   TRUNC(123.456, 2),
	   TRUNC(123.456, -2)
FROM DUAL;	

-- EMPLOYEE 테이블에서
-- 입사한 달이 홀수 달인 사원들의
-- 사번, 사원명, 입사일 조회
SELECT EMP_ID 사번, EMP_NAME 사원명, HIRE_DATE 입사일
FROM EMPLOYEE
WHERE MOD(SUBSTR(HIRE_DATE, 5, 1), 2) = 1
ORDER BY HIRE_DATE ;

-- MONTHS_BETWEEN() : 두 날짜 사이의 개월 수 
SELECT EMP_NAME, HIRE_DATE,
		TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) 개월수
FROM EMPLOYEE;

-- NEXT_DAY()
-- 앞으로 다가올 가장 가까운 요일을 반환함
-- 1. 일요일 ~ 7.토요일 
SELECT NEXT_DAY(SYSDATE, '토요일'),
		NEXT_DAY(SYSDATE, '일'),
		NEXT_DAY(SYSDATE, 6),
		NEXT_DAY(SYSDATE, 'SATURDAY')
FROM DUAL;

-- 현재 설정된 정보를 테이블 형태로 보관 -> 이러한 테이블을 '데이터 사전(데이터딕셔너리)'
SELECT * FROM V$NLS_PARAMETERS;

SELECT * FROM TABS;

-- LAST_DAY() : 마지막 일을 조회
SELECT LAST_DAY(SYSDATE)
FROM DUAL;

-- 날짜값 끼리 +, - 연산 가능
SELECT (SYSDATE-10),
		(SYSDATE - TO_DATE('2022/03/01', 'RR/MM/DD')),
		(SYSDATE + 30)
FROM DUAL;

SELECT (HIRE_DATE + 10)
FROM EMPLOYEE;

-- 
SELECT SYSDATE,
		TO_CHAR(SYSDATE, 'RR/MM/DD'),
		TO_CHAR(SYSDATE, 'YYYY-MM--DD HH:MI:SS'),
		TO_CHAR(SYSDATE, 'YEAR, Q')||'분기',
		TO_CHAR(SYSDATE, 'MON, YYYY')
FROM DUAL;		

-- 연도
-- Y/R
SELECT TO_CHAR(TO_DATE('190325', 'YYMMDD'), 'YYYY') "결과1",
	   TO_CHAR(TO_DATE('190325', 'RRMMDD'), 'RRRR') "결과2",
	   TO_CHAR(TO_DATE('800325', 'YYMMDD'), 'YYYY') "결과3",
	   TO_CHAR(TO_DATE('800325', 'RRMMDD'), 'RRRR') "결과4"
FROM DUAL;

-- 4자리 한번에 입력받는 경우는 문제x
-- 2자리 입력받을 경우
-- YY => 현 세기 기준으로 값을 추가
-- RR => 반 세기
SELECT TO_DATE('800325', 'YYMMDD')
FROM DUAL;

-- SELECT 문의 실행 순서
-- SELECT 컬럼 AS 별칭, 계산식, 함수
-- FROM 테이블명
-- WHERE 조건
-- GROUP BY 그룹을 묶을 컬럼명
-- HAVING 그룹에 대한 조건식, 함수식
-- ORDER BY 컬럼|별칭|순서 [ASC|DESC][, 컬럼명...]

-- GROUP BY -- 
SELECT EMP_ID, EMP_NAME 이름, SALARY, DEPT_CODE
FROM EMPLOYEE
-- ORDER BY EMP_ID;
-- ORDER BY 이름 DESC; 
ORDER BY 4;


-- 부서별 평균 급여 

-- 전체 사원의 급여 평균
SELECT TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE;

-- D1의 평균
SELECT TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE
WHERE DEPT_CODE = 'D1';

-- D6의 평균
SELECT TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE
WHERE DEPT_CODE = 'D6';

-- GROUP BY --
-- 특정 컬럼, 계산식을 기준으로
-- 그룹별로 묶어 한 테이블 내에서 소그룹별로 조회하고자 할 때 선언하는 구문
SELECT DEPT_CODE, TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

-- 부서 별 총인원, 급여 합계, 급여 평균, 최대급여, 최소 급여를 조회
-- 단, 부서코드 기준으로 오름차순
-- 급여평균은 100의 자리까지만 처리하고 나머지는 버림처리하여 확인
SELECT DEPT_CODE 부서, 
		COUNT(*) 총인원,
		SUM(SALARY) "급여 합계",
		TRUNC(AVG(SALARY), -5) "급여 평균",
		MAX(SALARY) "최대 급여",
		MIN(SALARY) "최소 급여"
FROM EMPLOYEE
GROUP BY DEPT_CODE;

-- 직급 코드별 보너스 받는 사원의 수 조회 
SELECT JOB_CODE, COUNT(BONUS)
FROM EMPLOYEE
GROUP BY JOB_CODE
ORDER BY 1;

-- GROUP BY 에서 주어진 컬럼 뿐만이 아니라 함수식도 사용 가능
SELECT DECODE(SUBSTR(EMP_NO, 8, 1), 2, '여성', '남성'), COUNT(*)
FROM EMPLOYEE
GROUP BY SUBSTR(EMP_NO, 8, 1);

-- 부서별 급여 평균을 구해서 조회
-- 단, 부서별 급여 평균이 300만원 이상인 부서만 조회
SELECT DEPT_CODE, AVG(SALARY) 평균
FROM EMPLOYEE
GROUP BY DEPT_CODE
--WHERE SALARY>3000000;

-- HAVING
SELECT DEPT_CODE, AVG(SALARY) 평균
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING AVG(SALARY) > 3000000;

-- 부서별 그룹의 급여 합계 중 900만원 초과하는 부서의
-- 코드와 급여합을 조회
SELECT DEPT_CODE, SUM(SALARY) 급여합
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) > 9000000;

-- 1) 급여 합계가 가장 높은 부서를 찾고
SELECT MAX(SUM(SALARY)) 급여합계
FROM EMPLOYEE
GROUP BY DEPT_CODE;
-- 17,700,000

-- 2) 해당 부서의 부서코드와 급여합계를 조회
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE 
HAVING SUM(SALARY)=17700000;

SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE 
HAVING SUM(SALARY)=(SELECT MAX(SUM(SALARY)) 
					FROM EMPLOYEE 
					GROUP BY DEPT_CODE);

-- 
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE 
ORDER BY 1, 2;

SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE 
ORDER BY 1;

SELECT EMP_NAME, DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE;

-- 집계함수 -- 
-- ROLLUP : 특정 그룹으로 묶은 뒤 해당 그룹에 대한 집계(총 합계)를 산출하는 함수
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE) 
ORDER BY 1, 2;

-- SET OPERATOR
-- 두개 이상의 SELECT 한 결과를 
-- 합치거나, 합칠 때 중복을 제거. 와 같은
-- 집합 형태의 결과로 조회하는 명령어

-- 합집합
-- UNION : 두개 이상의 SELECT한 결과(RESULT SET)를 구하는 명령어 
--			만약 중복이 있을 경우, 중복되는 결과는 1번만 보여준다.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

-- UNION ALL : UNION과 동일. 단, 중복이 있어도 그대로 조회 
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

-- 교집합 
-- INTERSECT : 중복되는 결과만 보여준다. 
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT 
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

-- 차집합
-- MINUS : 첫번째 결과에서 나머지 결과들과 일치하는 내용을 뺀 고유 결과를 조회 
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

-- [JOIN] -- 
-- 두 개 이상의 테이블을 하나로 합쳐 조회하는데 사용하는 명령 구문 

-- 'J6'이라는 직급을 가진 사원들의 정보를 조회하는데 ...
-- 근무 부서명이 궁금하다 ... 
SELECT EMP_NAME, JOB_CODE, DEPT_CODE
FROM EMPLOYEE
WHERE JOB_CODE = 'J6';

SELECT * FROM DEPARTMENT
WHERE DEPT_ID IN('D1', 'D8');

-- 오라클 전용 문법
-- FROM 절에 , 로 구분하여 합치게 될 테이블을 나열
-- 테이블을 엮는 기준으로 WHERE 조건을 명시한다. 
SELECT EMP_NAME, JOB_CODE, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

-- 표준 문법
-- FROM 다음에 JOIN 테이블명 ON() || USING() 구문 사용
SELECT EMP_NAME, JOB_CODE, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

SELECT *
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

-- 두 개의 테이블에서 공통 컬럼의 이름이 같은 경우
-- EMPLOYEE 테이블과 JOB 테이블 JOIN
SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;

SELECT EMP_ID, EMP_NAME, E.JOB_CODE, J.JOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE;

-- 표준 문법
SELECT EMP_ID, EMP_NAME, JOB.JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB ON (EMPLOYEE.JOB_CODE = JOB.JOB_CODE);

SELECT EMP_ID, EMP_NAME, J.JOB_CODE, JOB_NAME
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_CODE = J.JOB_CODE);

SELECT EMP_ID, EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

SELECT *
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

-- 사번, 사원명, 급여 등급(SAL_GRADE), 등급 기준 최소급여, 최대급여
-- EMPLOYEE 테이블
-- SAL_GRADE 테이블 

-- 두 테이블 정보 조회 (공통컬럼 : SAL_LEVEL)
SELECT * FROM EMPLOYEE;
SELECT * FROM SAL_GRADE;

-- 표준문법
SELECT EMP_ID, EMP_NAME, SAL_LEVEL, MAX_SAL, MIN_SAL
FROM EMPLOYEE E
JOIN SAL_GRADE S USING(SAL_LEVEL);


-- DEPARTMENT의 위치 정보와
-- LOCATION을 조인하여 
-- 각 부서별 근무지 위치를 조회.
-- 부서코드, 부서명, 근무지 코드, 근무지 위치 
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
-- D.LOCATION_ID = L.LOCAL_CODE

SELECT DEPT_ID, DEPT_TITLE, LOCATION_ID, LOCAL_NAME
FROM DEPARTMENT D
JOIN LOCATION L ON (D.LOCATION_ID = L.LOCAL_CODE);

-- INNER JOIN / OUTER JOIN
-- INNER JOIN : 둘 모두 일치하는 데이터만 합친다. 
-- OUTER JOIN : 둘 모두, 둘 중 하나가 가진 데이터 합친다 
SELECT DISTINCT DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE 
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

SELECT DISTINCT DEPT_CODE
FROM EMPLOYEE;

-- OUTER JOIN
-- LEFT JOIN : 두 테이블 중 원본 (왼쪽) 테이블의 정보를 모두 포함하여 조회.
-- RIGHT JOIN : 두 테이블 중 JOIN에 명시한 테이블의 정보를 모두 포함하여 조회.
-- FULL JOIN : 두 테이블이 가진 데이터 중 서로가 가지지 않은 값일지라도 모두 포함하여 조회.

-- INNER 
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);

-- LEFT
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);

SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;


-- RIGHT JOIN
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE 
RIGHT JOIN DEPARTMENT ON (DEPT_ID = DEPT_CODE);

SELECT *
FROM EMPLOYEE 
RIGHT JOIN DEPARTMENT ON (DEPT_ID = DEPT_CODE);

-- ORACLE 문법 
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT 
WHERE DEPT_CODE(+) = DEPT_ID;

-- FULL JOIN 
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE 
FULL JOIN DEPARTMENT ON (DEPT_ID = DEPT_CODE);

-- 추가적인 종류의 JOIN 
-- 기본적인 JOIN은 양 테이블 정보에서 하나씩은 일치하는 정보를 가지고 JOIN 수행
-- EQ(EQUAL) JOIN
-- 하지만, 서로 같은 값을 가지지 않은 테이블의 정보를 조회 할 경우 CROSS JOIN을 통해 JOIN 수행 가능 

SELECT * FROM EMPLOYEE;
SELECT * FROM NATIONAL;

SELECT * 
FROM EMPLOYEE
CROSS JOIN NATIONAL
ORDER BY 1;

-- NON-EQ JOIN
-- 특정 범위 내에 존재하는 조건으로 JOIN 수행

-- ON() 안에 계산식, 함수식 .. 다양하게 작성 가능
SELECT EMP_NAME, DEPT_CODE, SALARY, EMPLOYEE.SAL_LEVEL
FROM EMPLOYEE 
JOIN SAL_GRADE ON(SALARY BETWEEN MIN_SAL AND MAX_SAL);

-- SELF JOIN
-- 자기 자신을 JOIN 하는 방법 
SELECT E.EMP_ID "사번",
	   E.EMP_NAME "사원명",
	   E.MANAGER_ID "관리자 사번",
	   M.EMP_NAME "관리자명"
FROM EMPLOYEE E
JOIN EMPLOYEE M ON(E.MANAGER_ID = M.EMP_ID );

-- 다중 JOIN 
-- 여러 개의 테이블을 JOIN
-- JOIN시 순서에 주의해서 작성해야 한다.
SELECT *
FROM EMPLOYEE 
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE 
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);

-- ORACLE 구문
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE, DEPARTMENT, LOCATION 
WHERE DEPT_CODE = DEPT_ID 
	AND LOCATION_ID = LOCAL_CODE;

-- 한국(KO)과 일본(JP)에 근무하는 직원들의 정보 조회
-- 사원명, 부서명, 지역명, 국가명 
-- EMPLOYEE, NATIONAL, LOCATION, DEPARTMENT 
SELECT * FROM EMPLOYEE;		-- DEPT_CODE
SELECT * FROM NATIONAL;		-- NATIONAL_CODE 
SELECT * FROM LOCATION;		-- LOCAL_CODE -- NATIONAL_CODE
SELECT * FROM DEPARTMENT;	-- LOCATION_ID -- DEPT_ID 

SELECT EMP_NAME, D.DEPT_TITLE, L.LOCAL_CODE , N.NATIONAL_NAME
FROM EMPLOYEE E 
JOIN DEPARTMENT D ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION L ON (D.LOCATION_ID = L.LOCAL_CODE )
JOIN NATIONAL N ON (L.NATIONAL_CODE = N.NATIONAL_CODE )
WHERE NATIONAL_NAME IN('한국', '일본');

-- 문제 2.
-- 직급이 대리이면서, 아시아지역에서 근무하는 사원 조회
-- 사번, 사원명, 직급명, 부서명, 근무지역명, 급여
SELECT * FROM EMPLOYEE;
SELECT * FROM JOB; 
SELECT * FROM LOCATION;
SELECT * FROM DEPARTMENT;

SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE )
WHERE JOB_NAME IN('대리') AND LOCAL_NAME LIKE 'ASIA%';

--
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E
JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE AND JOB_NAME = '대리')
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE  AND LOCAL_NAME LIKE 'ASIA%');

-- ORACLE 구문
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E, JOB J, DEPARTMENT D, LOCATION L
WHERE E.JOB_CODE = J.JOB_CODE
	AND DEPT_CODE = DEPT_ID 
	AND LOCATION_ID = LOCAL_CODE 
	AND JOB_NAME = '대리'
	AND LOCAL_NAME LIKE 'ASIA%';

-- SUBQUARY 
-- 서브쿼리 




